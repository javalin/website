---
hidewhatsjavalin: true
permalink: /news/javalin-7.0.0-alpha.html
layout: default
category: news
date: 2026-01-20
version: 7.0.0
title: Javalin 7.0 alpha is ready!
summary: We're happy to announce the release of Javalin 7.0!
---
{% include socialButtons.html %}

<img src="/img/news/javalin7.png" alt="Javalin 7" style="border-radius:5px">

<h1 style="font-size:44px;display:flex;justify-content:space-between;align-items:center;margin-top:44px">
    <span>Introducing Javalin 7</span>
    <small style="font-weight:400;font-size:60%;color:rgba(0,0,0,0.5);">(TBD, 2026)</small>
</h1>
Javalin is a Java and Kotlin web framework focused on simplicity and seamless interoperability.
Built as a thin layer on top of the Jetty web server, it concentrates on the web layer without 
unnecessary abstraction.

Much of Javalinâ€™s success comes from the exceptionally supportive JVM open-source community.
After nearly eight years, the project sees over 1 million monthly downloads, 8.1k GitHub stars,
199 contributors, and 12k dependent projects. The core module is just ~10k lines of code,
backed by ~14k lines of tests, nearly 1k full integration tests, each starting and stopping 
a Javalin instance to validate real-world behavior.

**Let's have a look at Javalin 7!**

## Hello World
Javalin's main goal is simplicity and developer productivity.
The "Hello World" example in Javalin 7 reflects the new upfront configuration approach:
{% capture java %}
void main() {
    var app = Javalin.create(config -> {
        config.routes.get("/", ctx -> ctx.result("Hello World"));
    }).start(7070);
}
{% endcapture %}
{% capture kotlin %}
fun main() {
    val app = Javalin.create { config ->
        config.routes.get("/") { ctx -> ctx.result("Hello World") }
    }.start(7070)
}
{% endcapture %}
{% include macros/docsSnippet.html java=java kotlin=kotlin %}

## Building REST APIs with Javalin
Creating a REST API with Javalin is very straightforward.
Here's a complete server with a CRUD API:

{% capture java %}
var app = Javalin.create(config -> {
    config.routes.apiBuilder(() -> {
        path("users", () -> {
            get(UserController::getAll);
            post(UserController::create);
            path("{user-id}", () -> {
                get(UserController::getOne);
                patch(UserController::update);
                delete(UserController::delete);
            });
        });
    });
}).start(7070);
{% endcapture %}
{% capture kotlin %}
val app = Javalin.create { config ->
    config.routes.apiBuilder {
        path("users") {
            get(UserController::getAll)
            post(UserController::create)
            path("{user-id}") {
                get(UserController::getOne)
                patch(UserController::update)
                delete(UserController::delete)
            }
        }
    }
}.start(7070)
{% endcapture %}
{% include macros/docsSnippet.html java=java kotlin=kotlin %}

## Sending data to clients
Javalin 7 offers many convenient methods for sending responses:
{% capture java %}
ctx.result(stringOrStream);           // writes string or input stream to client (`text/plain` by default)
ctx.json(myJson);                     // serializes object to JSON string and writes to client (as `application/json`)
ctx.jsonStream(myJson);               // serializes JSON directly to client (nothing buffered in memory)
ctx.writeSeekableStream(myMediaFile); // stream audio and video to client (supports seeking/skipping)
ctx.future(myFutureSupplier);         // instructs Javalin to handle request asynchronously
ctx.render("/file.ext", model);       // render template or markdown file (as `text/html`)
{% endcapture %}
{% capture kotlin %}
ctx.result(stringOrStream)            // writes string or input stream to client (`text/plain` by default)
ctx.json(myJson)                      // serializes object to JSON string and writes to client (as `application/json`)
ctx.jsonStream(myJson)                // serializes JSON directly to client (nothing buffered in memory)
ctx.writeSeekableStream(myMediaFile)  // stream audio and video to client (supports seeking/skipping)
ctx.future(myFutureSupplier)          // instructs Javalin to handle request asynchronously
ctx.render("/file.ext", model)        // render template or markdown file (as `text/html`)
{% endcapture %}
{% include macros/docsSnippet.html java=java kotlin=kotlin %}

## Handling input from clients
Javalin also makes it easy to extract and validate client data:
{% capture java %}
ctx.body();                     // get the request body as a string (caches the body)
ctx.formParam("name");          // get a form parameter
ctx.queryParam("name");         // get a query parameter
ctx.uploadedFile("name");       // get an uploaded file

// JSON methods
ctx.bodyAsClass(Clazz);         // deserialize ctx.body() to class
ctx.bodyStreamAsClass(Clazz);   // consume input stream from request body and deserialize to class

// validation
var age = ctx.queryParamAsClass("age", Integer.class)  // wraps parameter in Validator
    .check(age -> age > 18, "NOT_OLD_ENOUGH") // adds check with error message
    .get(); // gets the validated value, or throws ValidationException
{% endcapture %}
{% capture kotlin %}
ctx.body()                      // get the request body as a string (caches the body)
ctx.formParam("name")           // get a form parameter
ctx.queryParam("name")          // get a query parameter
ctx.uploadedFile("name")        // get an uploaded file

// JSON methods
ctx.bodyAsClass<Clazz>()        // deserialize ctx.body() to class
ctx.bodyStreamAsClass<Clazz>()  // consume input stream from request body and deserialize to class

// validation
val age = ctx.queryParamAsClass<Int>("age")  // wraps parameter in Validator
    .check({ it > 18 }, "NOT_OLD_ENOUGH") // adds check with error message
    .get() // gets the validated value, or throws ValidationException
{% endcapture %}
{% include macros/docsSnippet.html java=java kotlin=kotlin %}

## WebSockets and Server-Sent Events
WebSockets and Server-Sent Events are also easy to set up:
{% capture java %}
config.routes.ws("/websocket/{path}", ws -> {
    ws.onConnect(ctx -> System.out.println("Connected"));
    ws.onMessage(ctx -> {
        var user = ctx.messageAsClass(User.class);
        ctx.send(user);
    });
    ws.onClose(ctx -> System.out.println("Closed"));
});

config.routes.sse("/sse", client -> {
    client.sendEvent("connected", "Hello, SSE");
    client.onClose(() -> System.out.println("Client disconnected"));
});
{% endcapture %}
{% capture kotlin %}
config.routes.ws("/websocket/{path}") { ws ->
    ws.onConnect { ctx -> println("Connected") }
    ws.onMessage { ctx ->
        val user = ctx.messageAsClass<User>()
        ctx.send(user)
    }
    ws.onClose { ctx -> println("Closed") }
}

config.routes.sse("/sse") { client ->
    client.sendEvent("connected", "Hello, SSE")
    client.onClose { println("Client disconnected") }
}
{% endcapture %}
{% include macros/docsSnippet.html java=java kotlin=kotlin %}

## Configuring Javalin
Javalin 7 makes configuration explicit and organized. Everything is configured upfront in the `create()` block:
{% capture java %}
var app = Javalin.create(config -> {
    // HTTP configuration
    config.http.asyncTimeout = 10_000L;
    config.http.generateEtags = true;

    // Router configuration
    config.router.ignoreTrailingSlashes = true;
    config.router.caseInsensitiveRoutes = true;

    // Static files
    config.staticFiles.add("/public", Location.CLASSPATH);

    // Custom resource handler (optional, for Jetty-free static file serving)
    config.resourceHandler(new JavalinStaticResourceHandler());

    // Jetty configuration
    config.jetty.defaultPort = 8080;
}).start();
{% endcapture %}
{% capture kotlin %}
val app = Javalin.create { config ->
    // HTTP configuration
    config.http.asyncTimeout = 10_000L
    config.http.generateEtags = true

    // Router configuration
    config.router.ignoreTrailingSlashes = true
    config.router.caseInsensitiveRoutes = true

    // Static files
    config.staticFiles.add("/public", Location.CLASSPATH)

    // Custom resource handler (optional, for Jetty-free static file serving)
    config.resourceHandler(JavalinStaticResourceHandler())

    // Jetty configuration
    config.jetty.defaultPort = 8080
}.start()
{% endcapture %}
{% include macros/docsSnippet.html java=java kotlin=kotlin %}

For a full list of configuration options, see the [documentation](/documentation#configuration).

## Plugins
Javalin's plugin system enforces plugin authors to provide a consistent API:

{% capture java %}
Javalin.create(config -> {
    config.registerPlugin(new ExamplePlugin(exampleConfig -> {
        exampleConfig.exampleSetting = "example";
    }));
});
{% endcapture %}
{% capture kotlin %}
Javalin.create { config ->
    config.registerPlugin(ExamplePlugin { exampleConfig ->
        exampleConfig.exampleSetting = "example"
    })
}
{% endcapture %}
{% include macros/docsSnippet.html java=java kotlin=kotlin %}

For more information about the plugin system, see [/plugins/how-to](/plugins/how-to).

## Upgrading from Javalin 6
Javalin 7 is a major release built on Jetty 12, with improved configuration and modularity.
If you're upgrading from Javalin 6, please follow the [migration guide](/migration-guide-javalin-6-to-7) for detailed instructions.

### Get involved
If you want to contribute to the project, please head over to
[GitHub](https://github.com/javalin/javalin) or [Discord](https://discord.com/invite/sgak4e5NKv).

If you want to stay up to date, please follow us on [Twitter](https://twitter.com/javalin_io).

{% include socialButtons.html %}

<style>
.post-content p {
    line-height: 1.7;
    text-wrap: pretty;
}
</style>

